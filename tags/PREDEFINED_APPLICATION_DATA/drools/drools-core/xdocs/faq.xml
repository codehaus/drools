<?xml version="1.0" encoding="ISO-8859-1"?>
<document url="http://drools.org/faq.xml">

  <properties>
    <title>FAQ</title>
    <author email="bob@eng.werken.com">bob mcwhirter</author>
  </properties>

  <body>
    <title>Frequently-Asked Questions</title>

    <section name="General">

    <subsection name="What is drools?">
      <p>
      <code>drools</code> is a dynamic rules engine for Java, based upon the
      Rete/Rete-OO algorithm and supported by a pluggable semantics modules.
      </p>
    </subsection>

    <subsection name="What happened to 1.0?">
      <p>
      <code>drool</code> 1.x was written before we knew anything about
      the Rete algorithm.  It was purely a predicate-execution framework
      and was never truly publically released.  With the massive changes
      undertaking for the 2.x series, we decided to increase the major
      version number so as to indicate the size of the change.
      </p>
    </subsection>

    </section>

    <section name="Algorithms">

    <subsection name="What's Rete?">
      <p>
      Rete is an algorithm devised by Charles Forgy in the early
      1980's to efficiently match conditions of rules when many
      objects are being observed by many rules.  It's basically
      a structure to allow progressive relational joins across
      tables.
      </p>
    </subsection>

    <subsection name="What's Rete-OO?">
      <p>
      Rete-OO is Bob McWhirter's adaptation of Charles Forgy's original Rete
      algorithm,
      tailored for object-oriented constructs.  The base algorithm
      is the same, but extra nodes in the network have been created.
      These nodes aide the binding to object-oriented semantics
      systems.
      </p>
    </subsection>

    <subsection name="How do the graphs differ?">
      <p>
      In Rete, all 1-input/1-output nodes were conditions which
      filtered passing tuples.
      </p>

      <p>
        <img src="./images/rete.gif" />
      </p>
      <p>
      Rete-OO adds two other types of 1-input/1-output node: the <i>parameter</i> and
      <i>extraction</i> nodes.
      </p>

      <p>
      An object by itself constitutes a fact.  The object may be unnamed and
      anonymous.  The parameter nodes serve to create the initial tuple wrapper
      with a single column and then bind the object to the column.  Parameter
      effectively act as the initial symbol-table populator so that rules have
      a named handle for accessing the object.
      </p>

      <p>
      The extraction nodes serve to model inter-object navigation and relationships.
      Given a single object, more information can be derived, or <i>extracted</i>,
      by following references to other objects.  These nodes then store the extracted
      data in new column in the tuple.
      </p>
      <p>
        <img src="./images/reteoo.gif" />
      </p>
    </subsection>

    </section>

    <section name="Semantics">

    <subsection name="What's a Semantic Module?">
      <p width="50%">
      Rules are written against objects, but the concept of
      an 'object' is fairly arbitrary and completely customizable
      using <b>Semantic Modules</b>.  A Java Semantic Module may
      regard any XML document simply as an object of type
      <i>org.dom4j.Document</i>, while an XML Semantic Module
      may differentiate between documents based upon their
      root element's name and namespace-uri.  It's up to you.
      </p>

      <p>
      A <a href="./apidocs/org/drools/smf/SemanticModule.html">SemanticModule</a>
      simply aggregates and packages a collection of
      <a href="./apidocs/org/drools/spi/SemanticComponent.html">SemanticComponents</a>.
      The semantic components simply define the concepts of "object type",
      "fact extraction" and "filter condition" that are used by the Rete-OO engine.
      </p>

    </subsection>

    <subsection name="What's a Semantic Componet?">
      <p>
      The Rete-OO algorithm works in terms of abstract interfaces to
      to various semantic-implying components, such as
      <a href="./apidocs/org/drools/spi/ObjectType.html">ObjectType</a> and
      <a href="./apidocs/org/drools/spi/Condition.html">Condition</a>
      Each semantic component has a very minimal interface that is
      implemented in order to inject application-specific semantics
      into the core algorithmic engine.
      </p>
    </subsection>

    </section>

  </body>
</document>

