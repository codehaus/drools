
%%
%%
%% Rete-OO
%%
%%

\documentclass[10pt,twocolumn,letterpaper,colorhighlight]{article}


%%
%% Package Imports
%%

\usepackage{fullpage}
\usepackage{alltt}
\usepackage{cite}
\usepackage{plain}
\usepackage{epic}
\usepackage{ecltree}
%\usepackage{fancybox}
\usepackage{ftnright}
\usepackage{hyperref}

%%
%% Margin Adjustments
%%

\addtolength{\oddsidemargin}{-.5in}
\addtolength{\evensidemargin}{-.5in}
\addtolength{\textwidth}{.75in}
\addtolength{\topmargin}{-.5in}
\addtolength{\textheight}{1.25in}

%%
%% Extra Commands and Evironments
%%

% \newenvironment{codelisting}%
	% {\begin{Sbox}\begin{minipage}{250pt}\small\begin{alltt}}%
	% {\end{alltt}\end{minipage}\end{Sbox}\fbox{\TheSbox}}

\newenvironment{codelisting}%
	{\begin{minipage}{250pt}\small\begin{alltt}}%
	{\end{alltt}\end{minipage}}


\begin{document}

\let\footnoterule\hrule
\setlength{\skip\footins}{10pt plus 5pt minus 3pt}

\makeatletter

\renewcommand{\@makefntext}[1]%
	{\noindent\makebox[1.8em][r]{\@makefnmark}#1}

\makeatother

% \long\def\@makefntext#1{\parindent 1em
  % \noindent\hbox to 2em{}%
  % \llap{$\@thefnmark.\;\;$}#1}


%% \preparefootins

\title{The Rete-OO Algorithm for Inference Rules\\in Object-Oriented Language Systems}

\author{Bob McWhirter\\bob@werken.com\\http://werken.com/}
\maketitle

%% 
%% Abstract
%% 

\begin{abstract}
Converting the Rete algorithm to work naturally in an object-oriented
environment is fairly straight-forward.  By addressing a new type of
fact model, along with a fact-pulling mechanism\footnote {As opposed
to traditional fact-pushing mechanisms.}, integrating a rules-engine with
an object-oriented language is possible.  In addition to the
convention Rete nodes, additional types must be created to adequately
and efficiently use object-oriented constructs in a Rete network.
\end{abstract}

%% \tableofcontents
%% \listoffigures

%%
%% A Brief History of Rete
%%

\section{A Brief History of Rete}

Charles Forgy developed the Rete algorithm \cite{forgy82rete} for
implementing inference engines in Lisp systems.  Facts are 
presented to the system in terms of Cambridge-prefix 
expressions~(Figure \ref{example.facts}), and rule conditions 
within each rule are defined in terms of facts with variables in place of various
arguments (Figure \ref{example.conditions}).

	\begin{figure}[hb]
	\begin{codelisting}
	(person 
	    ^id          bob    
	    ^parent-id   bill  
	    ^name        robert   
	    ^sibling-id  billy)
	(person 
	    ^id          billy  
	    ^parent-id   bill  
	    ^name        william  
	    ^sibling-id  bob)
	(person 
	    ^id          bill                    
	    ^name        william)
	\end{codelisting}

	\caption{Example facts.}
	\label{example.facts}
	\end{figure}

%%
%%
%%
%%

	\begin{figure}
	\begin{codelisting}
	(person 
	    ^id         <person1-id>   
	    ^parent-id  <parent-id>)
	(person 
	    ^id         <person2-id>   
	    ^parent-id  <parent-id>)
	\end{codelisting}

	\caption{Example condition patterns.}
	\label{example.conditions}
	\end{figure}

A rule is composed of one-or-more condition patterns.  Any variable
that has the same name in multiple conditions must represent the same
value throughout the rule.  

The rule conditions in Figure \ref{rule.cambridge} will match against two facts that
express that \verb|person1| and \verb|person2| have the same parent,
and at least one of them has the same name as that parent:

	\begin{figure}
	\begin{codelisting}
	(person 
	    ^id         <person1-id>  
	    ^name       <name>  
	    ^parent-id  <parent-id>)
	(person 
	    ^id         <person2-id>                
	    ^parent-id  <parent-id>)
	(person 
	    ^id         <parent-id>   
	    ^name       <name>)
	\end{codelisting}

	\caption{Example \emph{if} block in Cambridge-prefix form.}
	\label{rule.cambridge}
	\end{figure}

Once a rule is matched, the values bound to each variable is available
for the action portion of the rule, often called the \verb|then|
block.

For example, attributes can be added to tokens matched in the condition
(Figure \ref{rule.cambridge.modify}).  Also, completely new facts can be
added to the \emph{working memory} (Figure \ref{rule.cambridge.make}).

	\begin{figure}[ht]
	\begin{codelisting}
	(modify 1 
	    ^sibling-id  <person2-id>)
	(modify 2 
	    ^sibling-id  <person1-id>)
	\end{codelisting}
	\caption{Example \emph{then} block adding attributes.}
	\label{rule.cambridge.modify}
	\end{figure}

	\begin{figure}[ht]
	\begin{codelisting}
	(make 
	    (friends 
	        ^first   <person1-id>
	        ^second  <person2-id>))
	\end{codelisting}
	\caption{Example \emph{then} block asserting a new fact.}
	\label{rule.cambridge.make}
	\end{figure}

The Rete network maintains a progressive relational join structure to allow for 
efficient matching of conditions.  Each type of condition pattern
represents a table, where each variable within the pattern is 
modelled as a column in that table.  When the same variable
appears in multiple conditions, consistency is maintained by joining
on that variable's column across the tables that include it.

%%
%% Challenges of Rules in an Object-Oriented Environment
%%

\section{Challenges of Rules in an\\Object-Oriented Evironment}

Many object-oriented environments, such as Java and C++ applications,
expressing facts and condition patterns in a prefix notation
is unnatural, and doesn't map directly to normal programming
constructs which involve objects and methods, typically.  Any sort of
translation from objects to declared facts on the part of the
programmer is inconvenient.

In traditional Rete-based systems, the absence of a fact represents
that the fact is false. The programmer must explicitly assert the entire
collection of facts that he wishes the system to be aware
of\footnote{Aside from facts which the system itself will infer, of course.}.  With
objects, the object itself is a fact, and the results of calling
methods upon that object also represents facts.  

There have been other attempts to make a seamless object-orient
Rete-based rules engine but the goal has not quite been met. In Rete++
\cite{haley93seamless}, the classes upon which rules may react
must still be defined using a Lisp syntax.  The tool then produces C++
class definitions for use in the application.  This requires knowledge
during application construction, of exactly which classes might
interact with the rules engine.  Additionally, rules are expressed in
terms of member fields instead of instance methods, which breaks
encapsulation, one of the fundamental idioms of object-oriented
programming.

By using language features such as introspection in Java, any class
may be used within the rules system.  Knowledge of participation is
not required at compilation time.  Even classes provided by
third-parties that do not include source-code may participate in
rule condition matching.

In Java, a person might be modeled using a class which defines a
person, his parents, and his name (Figure \ref{Person.class})
Each instance of this class, if presented to the rules engine
represents three different types of facts.  There are identity facts,
data facts, and relationship facts.


	\begin{figure}
	\begin{codelisting}
	public class Person
	\{
	    private Person mother;
	    private Person father;
	    private String name;

	    public Person(String name,
	                  Person mother,
	                  Person father)
	    \{
	         this.name   = name;
	         this.mother = mother;
	         this.father = father;
	    \}

    	public boolean hasParent(Person person)
    	\{
	         return ( this.mother == person
	                  ||
	                ( this.father == person );
    	\}
	
    	public String getName()
    	\{
	         return this.name;
    	\}
	\}
	\end{codelisting}
	\caption{Java class defining a Person.}
	\label{Person.class}
	\end{figure}

	\begin{itemize}
		\item The person represented by the\\instance of the Person class exists
		\item The person has a specific name
		\item Another person may (or may not)\\ be one of this person's parents.
	\end{itemize}

Other indirect facts are also obtainable from the objects reachable
from the original presented object. Not only is the name of the person
available as a fact, but facts regarding the name exist, relating to
the methods on the \verb|String| class.

	\begin{itemize}
		\item The length of the name
		\item The first character of the name.    
		\item The name sorts before or after another name.
		\item The name is the same as (or different than)\\another name
	\end{itemize}

The programmer has expressed all of these facts (and more) by simply creating and
using instances of the \verb|Person| class, and asserting them into
the \emph{working memory}. He should not be required
to further express these facts to a rules-engine.  Doing so would
cause unnecessary, and possibly erroneous, duplication of data.
Instead presenting just the object itself to the rules system should
be sufficient for expressing all facts known about the object.

Condition patterns should be readily expressible using normal OO
idioms, also.  Normal boolean logic and \emph{consistent assignment} 
allow a programmer to naturally specify the condition patterns to be
matched for a rule (Figure \ref{example.exprs}).

	\begin{figure}
	\begin{codelisting}
	person1.hasParent( parent )
	person2.hasParent( parent )
	name = person1.getName();
	name = parent.getName();
	\end{codelisting}

	\caption{Examples of \emph{filter~expressions} and \emph{consistent
	assignments}.}
	\label{example.exprs}
	\end{figure}

%%
%% Adapting Rete to an Object-Oriented Environment
%%

\section{Rete-OO: Adapting Rete to an\\Object-Oriented Environment}

Adapting a Rete-based system seamlessly to an object-oriented
environment requires both a new condition pattern syntax and through a
modified and augmented Rete network structure.  The condition syntax should
follow the host language, such as Java or C++. The new network
structure is universal to any language using an object-oriented syntax
for condition specification.

\subsection{Rule Condition Syntax}

While the actual Rete algorithm is relatively language-independent,
rule conditions have traditionally been specified using a Lisp-like
notation, and typically used within a Lisp host
environment. Conversion to a modern object-oriented syntax is
desireable when using a rules system from within Java or C++.

Instead of specifying facts as patterns or class-based attribute
expressions, whole objects are presented to the system as \emph{root
fact objects} from which more facts my be pulled.  Gupta's description
of Rete \cite{gupta89highspeed} indicates a slight object-oriented
flavor, through the use of class-based expressions with attributes
true object-identity, object-referencing and encapsulation is not provided.

In object-oriented expressions, multiple objects may interact to produce
some result: a truth value or an object\footnote{The expression may
even be a simple object-identity expression.}.  An object-oriented 
expression syntax is required to correctly specify these
relationships, and the host language is a natural fit 
(Figure \ref{example.object-based.patterns}).

	\begin{figure}
	\begin{codelisting}
	person
	person.getName()
	person.getNumberOfCats()
	person.likes( place )
	place.hasGoodFood()
	place.hasFood( soup )
	soup.isGoodFood()
	person.hasParent( anotherPerson )
	person.likes( soup )
	store.hasItems( soup.getIngredients() )
	\end{codelisting}

	\caption{Example of object-based fact expressions.}
	\label{example.object-based.patterns}
	\end{figure}

Through the notion of \emph{consistent assignment} (Figure
\ref{example.expr.consistent-assignment}), the notion the Rete \emph{join
node} appears, which ensures that all variables that share a name are also equivalent.
Considering the expressions in figure \ref{example.expr.consistent-assignment}, for any two
objects \verb|person| and \verb|place|, to be considered a match they
must both have the same name as returned by their respective
\verb|getName()| methods. The two expressions create two new facts
bound to the identifier \verb|name|, and through consistent assignment
rules, only those pairs of objects which can create both \verb|name|
facts with equivalent values are considered for further processing.

	\begin{figure}
	\begin{codelisting}
	name = person.getName()
	name = place.getName()
	\end{codelisting}

	\caption{Example of consistent assignment.}
	\label{example.expr.consistent-assignment}
	\end{figure}

Both Java and C++ are \emph{strongly-typed} languages, which require
that all variables be declared of a particular type. Variables may
contain objects of the declared type or its subclasses. In
object-oriented Rete, there are two types of object declarations: 

	\begin{enumerate}
		\item Rule parameter object declarations.
		\item Internal local object declarations.
	\end{enumerate}

The \emph{rule parameter object declarations} represent the object that
must have been explictly asserted into the \emph{working memory}, either
from an external source or internally, as the result of an inference.
Any object directly added to the \emph{working memory} is considered a
\emph{root fact object}.

The \emph{internal local object declarations} represent any fact
extracted from a \emph{root fact object} and bound to a name.
Assignments made during a \emph{consistent assignment expression} must
assign to some previously declared variable; parameter or local. An
\emph{anonymous fact object} requires no local declaration since it 
never gets bound to a name.  Anonymous fact objects may be the result of
boolean expressions or simply occur in the middle of a method call
chain (Figures \ref{example.anonymous-fact-objects.boolean} and
\ref{example.anonymous-fact-objects.chain}).

	\begin{figure}
	\begin{codelisting}
	person.hasTenToes()
	\end{codelisting}

	\caption{Example of boolean expression anonymous fact object}
	\label{example.anonymous-fact-objects.boolean}
	\end{figure}


	\begin{figure}
	\begin{codelisting}
	person.\emph{getFather().getFather()...}
	\end{codelisting}

	\caption{Example of anonymous fact objects in method call chain.}
	\label{example.anonymous-fact-objects.chain}
	\end{figure}

Expressions that have a boolean result are treated as special filter
conditions and do not require assignment to a locally declared
variable\footnote{Assignment is allowed, but then the expression
is simply a \emph{consistent assignment} and the filter
aspects of are negated.  To have the same semantics as a filter
expression, a subsequent consistent assignment to \emph{true} is
required.}. Not all expressions resulting in a truth value are allowed,
as expressions involving \emph{logical OR} could potentially present 
a \emph{union problem}, where depending on the portion(s) of the 
expression that yielded \emph{true}, different objects would be passed
to subsequent conditions.  Expressions involving \emph{logical AND} are not
required, since all conditions are implicitly linked with a 
\emph{logical AND}%
	\footnote{%
		It would be possible to allow \emph{some} expressions that
		involve \emph{logical OR} if the set of variables referenced
		on either side of the operator were the same.  \emph{Logical
		AND} expressions pose no problems, and should be allowed if
		\emph{logical OR} expressions are functional, to simplify
		writing rules.
	}.

An complete example of the proposed syntax can be seen in Figure
\ref{example.syntax.complete}.

\begin{figure}
	\begin{codelisting}
	rule ExampleRule(Person person1,
	                 Person person2,
	                 Person parent)\footnote{\emph{person1}, \emph{person2}, and \emph{parent} are parameter object declarations.}
    \{
        String name;\footnote{local object declaration}

        when 
        \{
            person1.isTall();\footnote{boolean-based filter expression.}
            person2.isTall();\footnote{boolean-based filter expression.}
            name   = person1.getName();\footnote{consistent assignment across local object declaration \emph{name}.}
            name   = parent.getName();\footnote{consistent assignment across local object declaration \emph{name}.}
            parent = person1.getParent();\footnote{Consistent assignment across parameter declaration \emph{parent}.}
        \}

        then
        \{
            ....
            ....
        \}
    \}
	\end{codelisting}
	\caption{Complete example of condition syntax.}
	\label{example.syntax.complete}
\end{figure}

\subsection{Modified Rete Network Nodes}

Where Forgy's Rete has the following four types of nodes:

	\begin{enumerate}
		\item \emph{Constant-test nodes.} Each test either the class
					or a single constant attribute of a condition.
		\item \emph{Memory nodes.} Hold incoming tokens, making them 
					available to the \emph{Join nodes} for selection.
		\item \emph{Join nodes} (also known as \emph{Two-input nodes}.)
					Performs joins across its left and right input
					nodes\footnote{The input nodes of a \emph{join
					node} are always \emph{memory nodes}.}, and 
					propagate matching tokens to the next node.
		\item \emph{Terminal nodes.} Execute some action once the
					entire condition set is matched.
	\end{enumerate}

Rete-OO has the follow seven types of nodes:

	\begin{enumerate}
		\item \emph{Object type nodes.} A specialization of Forgy's
				\emph{constant-test node} which tests class compatiblity
				of a newly asserted \emph{root fact object}.
		\item \emph{Parameter nodes.} Converts a \emph{root fact
				object} into a tuple capable of traversing the rest
				of the Rete-OO network.
		\item \emph{Filter nodes.} Evaluate a boolean-resulting
				expression against values in the incoming tuple.
		\item \emph{Constant-test Nodes.} A specialization of
				Forgy's \emph{constant-test node} which asserts
				a \emph{consistent assignment} to a literal 
				constant value.  Compares the literal constant to
				a value stored in the tuple.
		\item \emph{Column generator nodes.} Generates an additional
				column for the incoming tuple from a \emph{consistent
				assignment} expression.
		\item \emph{Join nodes.} A mixture of Fogy's \emph{join node}
				and \emph{memory nodes}.  
		\item \emph{Terimnal nodes.} Analogous to Forgy's
				\emph{terminal node}.
	\end{enumerate}

\subsubsection{Object Type Nodes}

The first type of node directly under the root node is the 
\emph{object type node}, which filters incoming object 
by class.  It accepts \emph{root fact objects}, and 
simply filters out those that are not acceptable.  It has 
multiple outputs to \emph{parameter nodes}.  There is
one \emph{object type node} for each class mentioned 
in all rule \emph{parameter object declarations}.

\subsubsection{Parameter Nodes}

\emph{Parameter nodes} represent \emph{parameter object
declarations} in each rule.  For each declaration, a
\emph{parameter node} is created, with its input corresponding
to the \emph{object type node} which matches the declared
object type, and a \verb|name| property which matches the
declared object identifier.  It accepts objects from its
input, and simply creates a \emph{tuple} with a single
column named by the \verb|name| property, with the incoming
object as its value. It then propagates the newly created
\emph{tuple} to its single output node, which may be one
of the remaining types of nodes.

\subsubsection{Filter Nodes}

A \emph{filter node} is created for each condition expression
which yields a boolean truth value. It accepts a \emph{tuple} that 
contains at least the set of column referenced by the condition expression.
It evaluates the expression with the values stored in the
\empty{tuple}, propagating those \emph{tuples} that allow the
expression to evaluat to \emph{true}.

\subsubsection{Constant-test Nodes}

\emph{Constant-test nodes} are created for each \emph{consistent
assignment} that has only a constant on the right-hand side. It tests
incoming \emph{tuple}s to ensure that the value bound to the identifier
in the assignment matches the constant.  All \emph{tuples} passing
the constant-test are propagated to the next node in the network.

\subsubsection{Column Generator Nodes}

New to Rete-OO is the concept of a \emph{column generator node}.
When a \emph{consistent assignment} occurs with a complex
expression on the right-hand side of the assignment operator, this
represents a synthesized column. At this point, a new fact must
be pulled from the previously known facts, with the result being
added to the \emph{tuple}.

For example, the expression '\verb|age = person.getAge()|' adds 
a \verb|age| column to a tuple that contains a \verb|person| column%
\footnote{Since a method-call may sometimes require intense resources to
execute, ideally the result of the call would be cached if multiple
condition expressions require the same synthesized fact.  In Java,
a simple cache keyed by \emph{java.lang.reflect.Method} called
to generate the fact would be sufficient.}.
\emph{Column generator nodes} are not created for \emph{anonymous
fact objects} that might occur on the right-hand side of a
\emph{consistent assignment} nor for those that occur within
a \emph{filter expression}\footnote{\emph{Anonymous fact objects}
could still be cached through the same \emph{Method}-keyed
mechanism.}.

If the \emph{column generator node} generates a column that also
has a \emph{constant-test node}, then the \emph{constant-test node}
immediately follows the \emph{column generator node}. Otherwise, 
\emph{column generator nodes} may be followed by a \emph{join
node}, another \emph{column generator node}, or a \emph{terminal
node}.

\subsubsection{Join Nodes}

\emph{Join nodes}, similar to Forgy's, ensure that a variable
appearing in multiple condition expressions is consistent. They
internally include Forgy's notion of \emph{memory nodes}.  They
maintain a \emph{left memory} and a \emph{right memory}, each
linked to a previous node in the network.  When a \emph{tuple} arrives
on one of the inputs, it is joined against all tuples already stored
in the other side.  All tuple pairs which have equivelence across 
all common columns are concatenated and propagated to the following
node in the network.

\emph{Join nodes} may be followed by a \emph{column generator
node} another \emph{join node}, or a \emph{terminal node}.

\subsubsection{Terminal Nodes}

The \emph{terminal nodes} behave exactly as Forgy's terminal nodes,
and are the only leaves of the network. When a \emph{tuple} reaches
a \emph{terminal node}, the rule has been successfully matched by
a combination of \emph{root fact objects} and their synthesized
named fact objects.  The \emph{terminal node} is responsible for
executing the action associated with the rule.


\section{Construction of the\\Rete-OO Network} 

The Rete-OO network%
	\footnote{Yes, I'm fully aware that ``rete'' is 
		Latin for ``network'', so it's a tad redundant.} 
is generated in an iterative fashion, 

\begin{enumerate}
	\item \emph{Object type nodes} are created for each type of
object in the parameter list of the rule, if not already in
existence.
	\item \emph{Parameter nodes} are attached to the appropriate {\it
object type node} for each object in the parameter list.
	\item All possible \emph{column generator nodes} are created
against the current leaf nodes of the network.  It may not be possible
to create all during the first iteration.
	\item As many \emph{join nodes} as possible are created while
avoiding the creation of leaf nodes that would prevent further column
generation node creation.
	\item Repeat steps 3 and 4 until all nodes are exhausted.
	\item Created terminal nodes to enact the {\it then} portion of
the rule.
\end{enumerate}

\section{Research Implementation}

An open-source Java implementation of the Rete-OO algorithm  was written by
the author, and is available a \verb|http://drools.org|.  It uses a
Java expression parser to analyze the expressions used in the
condition block so as to be able to build the appropriate Rete-OO
network structure. Additionally, using the Java reflection API,
conditions and actions are evaluated at run-time, and require no
compilation step.  Optimizations include \emph{constant assignment
expressions} and \emph{anonymous fact object caching}.


\bibliography{werken}
\bibliographystyle{acm}

\end{document}
