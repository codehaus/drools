\chapter[Semantics Provider Interface]{SPI\\\normalsize{Semantics Provider Interface}}

\section{Overview}

At its core, \drools{} is merely an algorithmic engine. The 
\emph{Semantics Provider Interface}, also known as the SPI,
provides for wrapping the \drools{} Rete-OO algorithm with
arbitrary application semantics. The semantics of several concepts are
left open for definition by an implementation.

\medskip

\begin{center}
  \begin{tabular}{|l|l|p{120pt}|}
    \hline
      \textsf{concept} & \textsf{interface} & \textsf{description} \\
    \hline
    \hline
      \footnotesize{object type} %
        & \texttt{\footnotesize{org.drools.spi.ObjectType}} %
        & \footnotesize{Differentiates objects by type} \\
    \hline
      \footnotesize{condition} %
        & \texttt{\footnotesize{org.drools.spi.Condition}} %
        & \footnotesize{Tests tuples}\\
    \hline
      \footnotesize{fact extraction} %
        & \texttt{\footnotesize{org.drools.spi.Extractor}} %
        & \footnotesize{Extracts attributes from objects} \\
    \hline
      \footnotesize{action} %
        & \texttt{\footnotesize{org.drools.spi.Consequence}} %
        & \footnotesize{The result of a rule match}\\
    \hline
  \end{tabular}
\end{center}

\medskip

Additionally, implementations of some of these interfaces must work
with the \verb|Tuple| and \verb|Declaration| objects that flow 
through the network.  

The SPI provides for \drools{} customizations to be tightly linked to
the core Rete-OO algorithm engine.  By using SPI implementations, no
external translation or mapping process is required.  Rules can be
expressed directly using the semantics provided by the semantics module
and manipulated directly by the engine.

\section{Semantic Objects}

\subsection{org.drools.spi.ObjectType}

While the type of any object presented to \drools{} through
the fact manipulation methods of a \verb|WorkingMemory| is determined
by the Java class of that object, \drools{} provides the
\verb|ObjectType| interface for determining the object's semantic type
within the algorithm.

In the \emph{XML Semantics Module}, all presented objects are of the
class \verb|Document|.  The \verb|ObjectType| implementation
for the module inspects the root-level XML element to determine the
object's type for the context of \drools{}.

Semantic modules provide implementations of the \verb|ObjectType|
interface that are able to determine an object's type within
a semantic realm.

\begin{figure}
\begin{codelisting}
public interface ObjectType
\{
    /** Determine if the passed Object belongs to 
     *  the object type defined by this ObjectType.
     *
     *  @param object The Object to test.
     *
     *  @return true if the Object matches this 
     *          object type, Otherwise false.
     */
    boolean matches(Object object);
\}
\end{codelisting}
\caption{\texttt{org.drools.spi.ObjectType} interface}
\label{code.ObjectType}
\end{figure}

The \verb|matches(..)| method can perform any necessary logic 
to determine if semantic type of the object matches the type described
by the \verb|ObjectType| implementation. If
the type does match, then \verb|true| is returned.  Otherwise, 
\verb|false| indicates a non-match. A single asserted object may 
match several \verb|ObjectTypes| as the core engine presents each 
object to every \verb|ObjectType| for type determination.  This
allows for a single rule-base to contain a multitude of rules 
written against many semantic realms.

\subsection{org.drools.spi.Declaration}

A \verb|Declaration| represents a named and typed object.  Internally,
the \drools{} engine uses strongly-typed semantic objects.  Named objects
involved in a rule have a \verb|Declaration| that binds an object
identifier to an \verb|ObjectType|.  If an object is bound to a
\verb|Declaration| then the \verb|ObjectType| of the \verb|Declaration|
must return \verb|true| from its \verb|matches(..)| method when
evaluated against the bound object.

\begin{figure}
\begin{codelisting}
public class Declaration
\{

    /** Retrieve the ObjectType of this Declaration.
     *
     *  @return The ObjectType of this Declaration.
     */
    public ObjectType getObjectType() \{ ... \}

    /** Retrieve the variable's identifier.
     *
     *  @return The variable's identifier.
     */
    public String getIdentifier() \{ ... \}
\}
\end{codelisting}
\label{code.Declaration}
\caption{\texttt{org.drools.spi.Declaration} class}
\end{figure}

\subsection{org.drools.spi.Tuple}

While the external \drools{} API is object-oriented, the core is still
constructed of nodes through which \emph{tuples} flow.  A tuple is
simply a dictionary of \emph{key-to-value} mappings.  A
tuple may be considered to be similar to a \emph{row} in a relational
database table, where the \emph{key} matches the column type and name, and
the \emph{value} matches the column data cell for that row.  

The key used to index the associated value is always a
\verb|Declaration| object. When an object is initially asserted into a
\verb|WorkingMemory| it gets wrapped by all matching \verb|ParameterNodes|
into single-column tuples with the object bound to the
\verb|Declaration| of each \verb|ParameterNode|.

An example set of tuples was presented in table
\fullref{table.tuplesets}. With the exception of the \verb|ObjectType|
interface, semantic modules operate on \verb|Tuple| objects. 

\begin{figure}
\begin{codelisting}
public interface Tuple
{
    /** Retrieve the value bound to a particular Declaration.
     *
     *  @param declaration The Declaration key.
     *
     *  @return The currently bound Object value.
     */
    Object get(Declaration declaration);

    /** Retrieve the Se of all Declarations active in this tuple.
     *
     *  @return The Set of all Declarations in this tuple.
     */
    Set getDeclarations();
}
\end{codelisting}
\label{code.Tuple}
\caption{\texttt{org.drools.spi.Tuple} interface}
\end{figure}

\subsection{org.drools.spi.Extractor}

Fact extration is the process of performing an operation upon a
\verb|Tuple| to create additional columns or attribute on the
\verb|Tuple|.  All \verb|Tuples| initially have a single column
matching a \verb|Declaration| of the rule.  Through fact
extraction additional columns can be added based upon knowledge
gained from the existing columns.

The \emph{Java Semantic Module} uses normal Java expressions to
extract other objects and values reachable from those already in the
\verb|Tuple|.  The \emph{XML Semantic Module} uses
XPath\cite{clark99xpath} expressions
to evaluate expressions against documents.  The extracted values are
associated with a \verb|Declaration| and inserted into the
\verb|Tuple|.

Semantics modules provide implementations of the \verb|Extractor|
interface to perform fact extraction. A \verb|Extractor| may
require more than a single column to perform extraction.  To specify
which columns are required, the \verb|getRequiredTupleMembers()| 
method should return an array of \verb|Declarations| which must 
be present in any tuple presented for extraction.

\begin{figure}
\begin{codelisting}
public interface Extractor
\{
    /** Retrieve the array of Declarations required by this 
     *  Extractor to perform extraction.
     *
     *  @return The array of Declarations expected 
     *          on incoming Tuples.
     */
    Declaration[] getRequiredTupleMembers();

    /** Extract a new fact from the incoming Tuple.
     *
     *  @param tuple The source data tuple.
     *
     *  @return The newly extract fact object.
     *
     *  @throws ExtractionException if an error occurs during
     *          fact extraction activities.
     */
    Object extractFact(Tuple tuple) throws ExtractionException;
\}
\end{codelisting}
\label{code.Extractor}
\caption{\texttt{org.drools.spi.Extractor} interface}
\end{figure}

\subsection{org.drools.spi.Condition}

A \verb|Condition| is a predicate which evaluates against
a \verb|Tuple| to determine if the \verb|Tuple| should pass or
fail the condition. The \verb|isAllowed(Tuple tuple)| method
allows the condition to be evaluated against a \verb|Tuple|.
If the \verb|Tuple| passes the filter, then the method should
return \verb|true| otherwise \verb|false| indicates that
the \verb|Tuple| does not pass.

Like the \verb|Extractor|, a
\verb|Condition| may only be applicable to \verb|Tuple|
objects that contain some minimal set of columns.  
\verb|Condition| implementations must also supply
the \verb|getRequiredTupleMembers()| method.

\begin{figure}
\begin{codelisting}
public interface Condition extends Condition
\{
    /** Retrieve the array of Declarations required
     *  by this condition to perform its duties.
     *
     *  @return The array of Declarations expected
     *          on incoming Tuples.
     */
    Declaration[] getRequiredTupleMembers();

    /** Determine if the supplied Tuple is allowed
     *  by this filter.
     *
     *  @param tuple The <code>Tuple</code> to test.
     *
     *  @return <code>true</code> if the <code>Tuple</code>
     *          passes this filter, else <code>false</code>.
     *
     *  @throws ConditionException if an error occurs during testing.
     */
    boolean isAllowed(Tuple tuple) throws ConditionException;
\}
\end{codelisting}
\label{code.Condition}
\caption{\texttt{org.drools.spi.Condition} interface}
\end{figure}

\subsection{org.drools.spi.Consequence}

When a collection of facts, represented by a \verb|Tuple| satisifies
all conditions of a rule then an \verb|Consequence| is given an opportunity
to fire and perform some activity.  Since \verb|Consequence|s may require
the ability to manipulate more facts, instaces are provided not only
the matching \verb|Tuple|, but also the current \verb|WorkingMemory|
instance. \verb|Consequence| also has a subclass named \verb|Action| which allows
directly modelling of trigger rules.  \verb|Action|  is purely a
marker interface.


\begin{figure}
\begin{codelisting}
public interface Consequence
\{    
    /** Execute the consequence for the supplied
     *  matching <code>Tuple</code>.
     *
     *  @param tuple The matching tuple.
     *  @param workingMemory The working memory session.
     *
     *  @throws ConsequenceException If an error occurs while
     *          attempting to invoke the consequence.
     */
    void invoke(Tuple tuple,
                WorkingMemory workingMemory) throws ActionInvokationException;
\}
\end{codelisting}
\label{code.Conseqeunce}
\caption{\texttt{org.drools.spi.Conseqeunce} interface}
\end{figure}

\newpage
