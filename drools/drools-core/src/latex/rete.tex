\section{Rete\index{Rete}}
\label{algo.rete}

Charles Forgy\index{Forgy, Charles} created the original Rete algorithm\cite{forgy82rete} 
around 1982 as part
of his DARPA-funded research.  Compared to many previous
production-matching algorithms, Rete was very advanced.  Even today,
there have been few improvements to it in the general
case\footnote{Both ILOG and Haley claim to have optimized Rete
algorithms, but details are not currently public.}.  Variations on 
Rete, such as TREAT \cite{miranker87treat}, may have different performance characteristics
depending on the environment.  Some perform better with large rule 
sets but small numbers of objects, while other perform well for 
steady-state environments, but react poorly to numerous successive 
changes in the data.

A \emph{Rete network}\index{Rete!network} is a graph through which data flows.
Originally, data was specified using Cambridge-prefix tuples since
Lisp-like languages were in style for logic programming.\footnote{As it is for many artificial
intelligence projects.}  The tuples were used to express attributes
about objects.  For example, tuples may be used to express a person's
name and her pets.  The tuples are dropped into the Rete network,
and those that reach the far end cause the firing of a rule.
The original production-matching was based upon matches against
tuple patterns.

\bigskip

The Rete network is comprise of two types of nodes:

\begin{itemize}
	\item \textbf{\textsf{1-input/1-output nodes}}\\
		The \emph{1/1} nodes are
		constrictive nodes that only allow matching tuples to
		flow through.  Any tuples that do not match are discarded
		by the node.
	\item \textbf{\textsf{2-input/1-output nodes}}\\
		The \emph{2/1} nodes simply connect the output arcs from two
		other nodes (either \emph{1/1} nodes or \emph{2/1} nodes) merging
		tuples from both the left and right incoming arcs
		into a single tuple on the outgoing arc.  Maintains a memory
		of tuples for matching against future facts.
\end{itemize}

A forest of \emph{1/1} nodes acts as the entry-point
into the entire Rete network for any incoming tuple.  The
network-entry  nodes filter tuples purely by their type.  
Tuples about dogs and tuples about cats may 
each have a different type and may be differentiated from each 
other by the \emph{1/1} network-entry nodes.

Each condition of a rule is merely a pattern for a particular tuple type.
The condition describes the attributes that a tuple must have and acts
as a filter.  Each condition is transformed into a \emph{1/1} node
that only allows tuples matching the specified attributes to pass.
An attribute value may be specified as a variable and implies that
the variable must hold the same value in all occurrences.
The \emph{1/1} filter nodes are attached to
the network downstream from the \emph{1/1} entry-node that
differentiates their tuple type.

Consider a condition such as ``For any person who has a dog that
has the same name as that person's sister's cat, then...''  This could
be expressed with the condition patterns of:

\medskip

\begin{tabular}{llll}

(1) & \texttt{( person} & \texttt{name=person?} & \texttt{sister=sister? )}\\
(2) & \texttt{( person} & \texttt{name=person?} & \texttt{dog=petName? )}\\
(3) & \texttt{( person} & \texttt{name=sister?} & \texttt{cat=petName? )}\\

\end{tabular}

\medskip

Condition \emph{\#1} models the sister relationship so
that the rule only applies to two people who are sisters.  The
\verb|person?| and \verb|sister?| tokens are variables that must be
consistent across any set of tuples that match this rule.  

Conditions \emph{\#2} and \emph{\#3} serve two roles.  The \verb|dog|
and \verb|cat| attributes share the same \verb|petName?| variable and
serve to identify two people who have a cat and a dog with the same
name.  They each contain a \verb|name| attribute with either the
variable \verb|person?| or \verb|sister?| which ties the last two
conditions back to the first two.

\begin{figure}[htbpc]
  \begin{center}
   \begin{minipage}{6in}
	\xymatrix {
		\bullet \ar[d] \\
		type(person) \ar[d] \ar[dr] \ar[drr] \\
%
	condition(1) \ar[dr] & condition(2) \ar[d] & condition(3) \ar[dd] \\
%
	       & join(1) \ar[dr] \\
%
	       & & join(2) \ar[d] \\
%
	       & & terminal \\
	}
  \end{minipage}
  \end{center}
  \label{network.rete}
  \caption{Rete network}
\end{figure}

\setlength{\extrarowheight}{3pt}


\begin{figure}[htbpc]
  \begin{center}
    \begin{tabular}{|c||c|c|c|c|}
      \hline
        \emph{\textsf{type}} %
            & \textsf{person} %
            & \textsf{sister} %
            & \textsf{cat} %
            & \textsf{dog} \\
      \hline
      \hline
        \multicolumn{5}{|c|}{\emph{tuple set \# 1}}\\
      \hline 
      \hline 
        person & rebecca & jeannie & zoomie & \emph{null} \\
      \hline
        person & jeannie & rebecca & \emph{null} & zoomie \\
      \hline
      \hline
        \multicolumn{5}{|c|}{\emph{tuple set \# 2}}\\
      \hline
      \hline
        person & rebecca & jeannie & zoomie & \emph{null} \\
      \hline
        person & jeannie & rebecca & \emph{null} & toby \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Example tuple sets}
  \label{table.tuplesets}
\end{figure}

\clearpage

If two sets of tuples (see Figure \ref{table.tuplesets}) were
asserted against the rule, \emph{tuple set \#1} would cause a firing
of the rule, where \emph{tuple set \#2} would not.  In both cases,
the two tuples would pass node \emph{condition(1)}, as the
nodes simply associate the \verb|person?| and \verb|sister?| variables
with the appropriate values from each tuple.

The \emph{join(1)} node would allow both tuples to merge and
propagate past it in both the first and second case.  Additionally,
for both cases, the \emph{rebecca} tuple would pass node
\emph{condition(2)}
and the \emph{jeannie} tuple would pass node \emph{condition(3)}.

The \emph{join(2)} node is where the two cases differ.  In the first
case, nodes \emph{condition(2)} and \emph{condition(3)} have each associated the value
of ``ugly'' to the \verb|petName?| variable.  In the second case, the
two nodes has assigned different values to the variable.  The
\emph{join(2)} node only allows those tuples that have consistent
associations with all variables to pass.

