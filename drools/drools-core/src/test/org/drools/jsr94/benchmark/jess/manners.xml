<?xml version="1.0" encoding="UTF-8"?>
<!--

The definition of a RuleExecutionSet is not within the scope of the JSR 94.
The implementation given in this file is written for the reference
implementation. A rule engine vendor verifying their rule engine should
modify this file to their specific needs.

Miss Manners is a program which handles the problem of finding an acceptable
seating arrangement for guests at a dinner party.  It will attempt to match
people with the same hobbies, and to seat everyone next to a member of the
opposite sex.  Manners is a small program, which has only few rules, and
employs a depth-first search approach to the problem.

-->
<rule-execution-set>

   <name>Miss Manners for Jess</name>
   <description>Stateless RuleExecutionSet for the Miss Manners benchmark</description>

   <code><![CDATA[

      (deftemplate guest (slot name) (slot sex) (slot hobby))

      (deftemplate last_seat (slot seat))

      (deftemplate seating
        (slot id) (slot pid) (slot seat1) (slot name1) (slot name2) (slot seat2) (slot path_done))

      (deftemplate path (slot id) (slot name) (slot seat))

      (deftemplate chosen (slot id) (slot name) (slot hobby))

      (deftemplate count (slot c))

      (deftemplate context (slot state))

      ;-----------------------------------------------------------------------------------------
      ; convert the java objects from the input list to Jess facts
      ;
      (defclass test.jsr94.benchmark.Guest  test.jsr94.benchmark.Guest)
      (defclass test.jsr94.benchmark.LastSeat  test.jsr94.benchmark.LastSeat)
      (defclass test.jsr94.benchmark.Context  test.jsr94.benchmark.Context)

      (defrule digestGuest
         ?obj <- (test.jsr94.benchmark.Guest)
         =>
         (bind ?i (call (call (fact-slot-value ?obj OBJECT) getHobbies) size))
         (while (> ?i 0) do
            (bind ?i (- ?i 1))
            (bind ?hobby (call (call (fact-slot-value ?obj OBJECT) getHobbies) get ?i))
            (assert (guest
               (name (sym-cat (fact-slot-value ?obj name)))
               (sex (sym-cat (fact-slot-value ?obj sex)))
               (hobby (sym-cat ?hobby))))
         )
         (retract ?obj))

      (defrule digestLastSeat
         ?obj <- (test.jsr94.benchmark.LastSeat)
         =>
         (assert (last_seat (seat (integer (fact-slot-value ?obj seat)))))
         (retract ?obj))

      (defrule digestContext
         ?obj <- (test.jsr94.benchmark.Context)
         (not (test.jsr94.benchmark.Guest))
         (not (test.jsr94.benchmark.LastSeat))
         (not (test.jsr94.benchmark.Count))
         =>
         (assert (context (state (sym-cat (fact-slot-value ?obj state)))))
         (retract ?obj))

      ;
      ;-----------------------------------------------------------------------------------------

      (defrule assign_first_seat
        ?ctxt <- (context (state start))
        (guest (name ?n))
        =>
        (assert (seating (seat1 1) (name1 ?n) (name2 ?n) (seat2 1) (id 1) (pid 0) (path_done yes)))
        (assert (path (id 1) (name ?n) (seat 1)))
        (assert (count (c 2)))
        (printout t seat " " 1 " " ?n " " ?n " " 1 " " 1 " " 0 " " 1 crlf)
        (modify ?ctxt (state assign_seats))
        )

      (defrule find_seating
        ?ctxt <- (context (state assign_seats))
        (seating (seat1 ?seat1) (seat2 ?seat2) (name2 ?n2) (id ?id) (pid ?pid) (path_done yes))
        (guest (name ?n2) (sex ?s1) (hobby ?h1))
        (guest (name ?g2) (sex ~?s1) (hobby ?h1))
        ?count <- (count (c ?c))
        (not (path (id ?id) (name ?g2)))
        (not (chosen (id ?id) (name ?g2) (hobby ?h1)))
        =>
        (assert (seating (seat1 ?seat2) (name1 ?n2) (name2 ?g2) (seat2 (+ ?seat2 1)) (id ?c)
            (pid ?id) (path_done no)))
        (assert (path (id ?c) (name ?g2) (seat ( + ?seat2 1))))
        (assert (chosen (id ?id) (name ?g2) (hobby ?h1)))
        (modify ?count (c (+ ?c 1)))
        (printout t seat " " ?seat2 " " ?n2 " " ?g2 crlf)
        (modify ?ctxt (state make_path)))

      (defrule path_done
        ?ctxt <- (context (state make_path))
        ?seat <- (seating (path_done no))
        =>
        (modify ?seat (path_done yes))
        (modify ?ctxt (state check_done)))

      (defrule make_path
        (context (state make_path))
        (seating (id ?id) (pid ?pid) (path_done no))
        (path (id ?pid)(name ?n1) (seat ?s))
        (not (path (id ?id) (name ?n1)))
        =>
        (assert (path (id ?id) (name ?n1) (seat ?s))))

      (defrule continue
        ?ctxt <- (context (state check_done))
        =>
        (modify ?ctxt (state assign_seats)))

      (defrule are_we_done
        ?ctxt <- (context (state check_done))
        (last_seat (seat ?l_seat))
        (seating (seat2 ?l_seat))
        ?count <- (count (c ?c))
        =>
        (printout t crlf "Yes, we are done!!" crlf)
        (modify ?count (c 1))
        (modify ?ctxt (state print_results)))

      (defrule print_results
        (context (state print_results))
        (seating (id ?id) (seat2 ?s2))
        (last_seat (seat ?s2))
        ?count <- (count (c ?c))
        ?path <- (path (id ?id) (name ?n) (seat ?c))
        =>
        (printout t ?c " " ?n crlf)
        (path2output ?path)
        (modify ?count (c (+ ?c 1))))

        ;-----------------------------------------------------------------------------------------
        ; convert a Jess path fact to a java object in the output list
        ;
        (defclass seat test.jsr94.benchmark.Seat)

        (deffunction path2output (?path)
            (bind ?seat (new test.jsr94.benchmark.Seat (fact-slot-value ?path seat) (fact-slot-value ?path name)))
            (definstance seat ?seat static)
        )
   ]]></code>

</rule-execution-set>
