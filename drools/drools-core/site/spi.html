<div class="section">

  <div class="sectionTitle">Semantics Provider Interface</div>
    <div class="subsection">
      <div class="subsectionTitle">Overview</div>
      <p>
      The Semantic Provider Interface (SPI) allows for extending Drools to more natively
      support the semantics of your domain.  The SPI defines a handful of interfaces that
      may be implemented to create new rule primitives.   Rule primitives are the parts
      that are stitched together to form a concrete rule.
      </p>
    </div>
    <div class="subsection">
      <div class="subsectionTitle"><a href="TOP/api/org/drools/spi/ObjectType.html">ObjectType</a></div> 
      <p>
      Each rule operates against some set of objects.  Each object may be categorized in one of many
      ways.  An XML documentment might be categorized based upon the root element when viewed within
      the semantics of XML.  But with the semantics of the Java language, each would simply be an
      instance of some <code>Document</code> class, indifferentiable from others.
      <p>
      <p>
      An <a href="TOP/api/org/drools/spi/ObjectType.html">ObjectType</a> implementation is required
      to contain only a single method, <a href="TOP/api/org/drools/spi/ObjectType.html#matches(java.lang.Object)">matches(...)</a>,
      which serves the same role as the <code>instanceof</code> operator in Java.  It inspects
      the given object and returns simple a boolean <code>true</code> if the object is considered
      to match the type or <code>false</code> if not.
      </p>

      <p>
      For example, an object-type used within an insurance system for a the employees of
      a company might be used to differentiate young employees from old employees.
      </p>

      <div class="code">
<pre>
public boolean <a href="TOP/api/org/drools/spi/ObjectType.html#matches(java.lang.Object)">matches</a>(Object object)
{
    if ( ! object instanceof Employee )
    {
        return false
    }

    Employee employee = (Employee) object;

    return ( employee.getAge() > 50 );
}
</pre>
      </div>

    </div>
    <div class="subsection">
      <div class="subsectionTitle"><a href="TOP/api/org/drools/spi/Condition.html">Condition</a></div> 
      <p>
      A set of <a href="TOP/api/org/drools/spi/Condition.html">Condition</a>s is used by each rule to
      determine when it should fire.  Each condition is given a set of objects to test against, returning
      either boolean <code>true</code> or <code>false</code>.  The combinations of objects that are
      presented to the condition is a <a href="TOP/api/org/drools/spi/Tuple.html">Tuple</a>.  A tuple is
      a map-like structure that maintains a correlation between a fact object and the 
      <a href="TOP/api/org/drools/rule/Declaration.html">Declaration</a> that it is bound to.
      <p>

      <p>
      For example, a rule might involve two Person objects, where the condition is "p1 is mother of p2".
      In this case, variable, <code>p1</code>, and <code>p2</code>, matches a declaration.  Two objects,
      <code>o1</code> and <code>o2</code>, can be bound to the declaration 4 different ways:
      </p>

      <ol>
        <li>{ p1=o1, p2=o2 } ... Object #1 bound to p1, Object #2 bound to p2.</li>
        <li>{ p1=o2, p2=o1 } ... Object #2 bound to p1, Object #1 bound to p2.</li>
        <li>{ p1=o1, p2=o1 } ... Object #1 bound to both p1 and p2.</li>
        <li>{ p1=o2, p2=o2 } ... Object #1 bound to both p1 and p2.</li>
      </ol>

      <p>
      In this scenario, only one of the first two tuples will ever satisfy the condition.  The
      particular binding is significant and each permutation must be tested.
      </p>
      <div class="code">
<pre>
public boolean <a href="TOP/api/org/drools/spi/Condition.html#isAllowed(org.drools.spi.Tuple)">isAllowed</a>(<a href="TOP/api/org/drools/spi/Tuple.html">Tuple</a> tuple)
    throws <a href="TOP/api/org/drools/spi/ConditionException.html">ConditionException</a>
{
    Person p1 = tuple.<a href="TOP/api/org/drools/spi/Tuple.html#get(org.drools.rule.Declaration)">get</a>( this.p1Decl );
    Person p2 = tuple.<a href="TOP/api/org/drools/spi/Tuple.html#get(org.drools.rule.Declaration)">get</a>( this.p2Decl );

    return p1.isMotherOf( p2 );
}
</pre>
      </div>

      <p>
      The Rete-OO algorithm requires knowledge about what declarations are being tested
      within each condition in order to build efficient datastructures.  Each condition
      implementation therefore is required to implement the <a href="TOP/api/org/drools/spi/Condition.html#getRequiredTupleMembers()">getRequiredTupleMembers()</a>
      method.  In the example above, the entire rule may invole a complex relationship
      between 12 people, while this particular condition is only relevant to objects
      <code>p1</code> and <code>p2</code>, but has no need for <code>p3</code> through
      <code>p12</code>.  
      </p>

      <div class="code">
<pre>
public <a href="TOP/api/org/drools/rule/Declaration.html">Declaration</a> <a href="TOP/api/org/drools/spi/Condition.html#getRequiredTupleMembers()">getRequiredTupleMembers</a>()
{
    return new <a href="TOP/api/org/drools/rule/Declaration.html">Declaration</a>[] { this.p1Decl, this.p2Decl };
}
</pre>
      </div>

    </div>
    <div class="subsection">
      <div class="subsectionTitle"><a href="TOP/api/org/drools/spi/Extractor.html">Extractor</a></div> 
      <p>
      <p>
    </div>
    <div class="subsection">
      <div class="subsectionTitle"><a href="TOP/api/org/drools/spi/Consequence.html">Consequence</a></div> 
      <p>
      <p>
    </div>
  </div>
</div>

